<?php
/**
 * Genius Open Source Libraries Collection
 * Copyright 2010 Team Lazer Beez (http://teamlazerbeez.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class gosDB_AutoDBGenerator
{
    /**
     * @var $dbNames array of permissible db names
     */
    private static $dbNames;

    public function __construct($validDBNames)
    {
        if (empty($dbNames))
        {
            self::$dbNames = $validDBNames;
        }
        gosDB_Util::setValidDBIdentifiers($validDBNames);
    }

    /**
     * Returns a test DB name that is unique across users for a passed DB name
     * @param string $dbName
     * @param string $uid A unique identifier (generated by calling time() outside this function)
     * @return string
     */
    public function generateTestDBName($dbName, $uid)
    {
        if (array_search($dbName, self::$dbNames) === false)
        {
            throw new gosException_InvalidArgument("DB name '$dbName' is not a known db", get_defined_vars());
        }

        // get the username from the environment
        $systemUser = $_ENV['USER'];

        // The dbName will be something like "main_akorn_123456789"
        $generatedDBName = $dbName .'_'. $systemUser . '_' . $uid;

        return $generatedDBName;
    }

    /**
     * Execute a SQL query
     */
    protected function executeQuery($connParams, $query)
    {
        $command = 'mysql -u '. escapeshellarg($connParams->getUser()) .' -p'. escapeshellarg($connParams->getPassword()) .' -h '. escapeshellarg($connParams->getHost()) .' -P '. $connParams->getPort() ." -e ". escapeshellarg($query) ."";
        $result = null;
        exec($command, $result);
        return $result;
    }

    /**
     * Remove unused databases. This is deteremined when a database is either older than
     * $dbTimeout, or a user has more than $maxDbsPerUser at which point the older ones go.
     */
    protected function removeOldDatabases(gosDB_ConnParams $connParams)
    {
        $dbTimeout = 20 * 60; // The age in seconds at which a db can be killed in this loop.
        $maxDbsPerUser = 2; // The max dbs per user, after which we delete the oldest ones.

        $dbBaseName = '';
        $dbMetaString = '';
        foreach (self::$dbNames as $dbName)
        {
            if (strpos($connParams->getDBName(), $dbName) !== false)
            {
                $dbBaseName = $dbName;
                $dbMetaString = preg_replace('/' . $dbName . '_/', '', $connParams->getDBName());
                break;
            }
        }

        if (empty($dbBaseName))
        {
            $databases = '';
            foreach (self::$dbNames as $dbName)
            {
                if (!empty($databases))
                    $databases .= ', ';
                $databases .= $dbName;
            }
            throw new gosException_StateError('dbname <' . $dbBaseName . '> not found in valid database names (' . $databases . ')', get_defined_vars());
        }

        // Should have three underscore-separated parts left: user, timestamp, millis
        $matches = explode('_', $dbMetaString);
        if (!$matches || count($matches) != 3)
        {
            throw new gosException_InvalidArgument('dbname is not in the correct format (dbName_user_timestamp_millis)', get_defined_vars());
        }

        $userName = $matches[1];
        // Grab the current time and all the existing test databases.
        $result = $this->executeQuery($connParams, '
            select SCHEMA_NAME from information_schema.SCHEMATA
            where SCHEMA_NAME like "'. $dbBaseName . '\_%"
            order by SCHEMA_NAME desc');

        $now = time();
        $userDbCount = array();
        foreach ($result as $dbFullname)
        {
            $matches = array();
            // Not all dbs are tmp dbs, so only consider ones that match the tmp db pattern.
            if (gosRegex::match('/(' . $dbBaseName . '_[a-z]+)_([0-9_]+)/', $dbFullname, $matches))
            {
                //var_dump($matches);
                $userDbString = $matches[1];
                // A period cannot be in a db name, so an underscore represents that.
                $timestamp = str_replace("_", ".", $matches[2]);
                $timestamp = (float)$timestamp;

                // Keep track of how many times we've seen DBNAME_USER, and DROP them after $maxDbsPerUser.
                if (isset($userDbCount[$userDbString]))
                {
                    $userDbCount[$userDbString] += 1;
                }
                else
                {
                    $userDbCount[$userDbString] = 1;
                }

                // Have there been too many dbs for this user? >= because right after this, we'll create another.
                if ($userDbCount[$userDbString] >= $maxDbsPerUser)
                {
                    // Set the db timestamp to zero so this gets cleared out, we have surpassed the max for this user.
                    $timestamp = 0;
                }

                // If the database is new enough, it is saved!
                if ($now - $timestamp < $dbTimeout)
                {
                    continue;
                }

                $this->executeQuery($connParams, 'DROP DATABASE IF EXISTS '. $dbFullname);
            }
        }
    }

    /**
     * @param $dbName string the db name used in the DDL for that db, e.g. 'mg'
     * or 'sfDump', NOT the db identifier ('main' or 'read').
     * @param gosDB_ConnParams $connParams
     * @return gosDB_ConnParams params to connect to the generated database
     */
    public function generateDBForSchema($dbName, gosDB_ConnParams $connParams, $schemaDir)
    {
        // By default prune dbs but allow for example phpu to disable for other than the first thread.
        if (getenv('PRUNEDBS') !== 'N')
        {
            $this->removeOldDatabases($connParams);
        }

        $this->executeQuery($connParams, 'DROP DATABASE IF EXISTS '. $connParams->getDBName());
        $this->executeQuery($connParams, "CREATE DATABASE ". $connParams->getDBName());

        // we assume that the files we get out of this are sorted in lexical order, seeing as there
        // is a "GLOB_NOSORT" flag that can be sent to this function.
        $schemaFiles = glob($schemaDir . '/*-' . $dbName . '*.sql', 0);

        sort($schemaFiles);

        // since we're only generating the schema, we don't need any
        // PreloadData files
        foreach ($schemaFiles as $key => $file)
        {
            if (strpos($file, 'PreloadData') !== false)
            {
                unset($schemaFiles[$key]);
            }
        }

        // now load in all of the schema files, which, as we noted above, will be in lexical order.
        foreach ($schemaFiles as $fileToLoad)
        {
            $this->loadSQL($fileToLoad, $connParams);
        }
    }

    /**
     * Load the specified file into the given db name
     * @param $filePath string
     * @param gosDB_ConnParams $connParams, used to
     * provide the host, port, user and password.
     */
    private function loadSQL($filePath, gosDB_ConnParams $connParams)
    {
        $cmd = 'mysql -u ' . escapeshellarg($connParams->getUser()) .' -p'. escapeshellarg($connParams->getPassword()) .' -h '. escapeshellarg($connParams->getHost()) .' -P '. $connParams->getPort() .' ' . escapeshellarg($connParams->getDBName()) . ' < ' . escapeshellcmd($filePath);
        //echo "executing $cmd\n";
        exec($cmd);
    }
}
